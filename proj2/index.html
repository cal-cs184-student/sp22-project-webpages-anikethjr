<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
  <style>
    body {
      padding: 100px;
      width: 1000px;
      margin: auto;
      text-align: left;
      font-weight: 300;
      font-family: 'Open Sans', sans-serif;
      color: #121212;
    }

    h1,
    h2,
    h3,
    h4 {
      font-family: 'Source Sans Pro', sans-serif;
    }
  </style>
  <title>CS 284A Mesh Editor</title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

  <h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2022</h1>
  <h1 align="middle">Project 2: Mesh Editor</h1>
  <h2 align="middle">Aniketh Janardhan Reddy and Aditya Ramkumar</h2>

  <br><br>

  <div>

    <h2 align="middle">Overview</h2>
    <p>Give a high-level overview of what you implemented in this project. Think about what you've built as a whole.
      Share your thoughts on what interesting things you've learned from completing the project.</p>

    <h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

    <h3 align="middle">Part 1: Bezier curves with 1D de Casteljau subdivision</h3>

    <p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a
      column in that row. You might find this useful for framing and showing your result images in an organized fashion.
    </p>

    <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="images/image1.png" align="middle" width="400px" />
            <figcaption align="middle">Caption goes here.</figcaption>
          </td>
          <td>
            <img src="images/image2.png" align="middle" width="400px" />
            <figcaption align="middle">Caption goes here.</figcaption>
          </td>
        </tr>
        <br>
        <tr>
          <td>
            <img src="images/image3.png" align="middle" width="400px" />
            <figcaption align="middle">Caption goes here.</figcaption>
          </td>
          <td>
            <img src="images/image4.png" align="middle" width="400px" />
            <figcaption align="middle">Caption goes here.</figcaption>
          </td>
        </tr>
      </table>
    </div>


    <h3 align="middle">Part 2: Bezier surfaces with separable 1D de Casteljau subdivision</h3>



    <h2 align="middle">Section II: Sampling</h2>

    <h3 align="middle">Part 3: Average normals for half-edge meshes</h3>


    <h3 align="middle">Part 4: Half-edge flip</h3>
    
    <p>We mapped out the pointer assignments that need to be performed in order to flip an edge on a piece of paper and then coded them up. By doing this, we did not face any major debugging challenges. The implementation tip on assigning all relevant pointers, even if redundant, was also very helpful. We use the notations from the figure below:</p>
    <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="images/flip.jpg" align="middle" width="400px" />
            <figcaption align="middle">Flip operation</figcaption>
          </td>
        </tr>
        <br>
      </table>
    </div>
    <p>To get pointers to the relevant half-edges, we perform the following operations (cur_edge is the edge to be flipped):</p>
    <ol>
      <li> The half-edge pointed to by cur_edge = cur_halfedge = cur_edge->halfedge() </li>
      <li> The twin of half-edge pointed to by cur_edge = twin = cur_halfedge->twin() </li>
      <li> The next half-edge of the triangle containing the half-edge pointed to by cur_edge = next = cur_halfedge->next() </li>
      <li> The half-edge from c to a = ca = next </li>
      <li> The half-edge from d to c = dc = twin->next()->next() </li>
      <li> The half-edge from a to b = ab = next->next() </li>
      <li> The half-edge from b to d = bd = twin->next() </li>
    </ol>

    <p>The pointers to the vertices can be obtained as:</p>
    <ol>
      <li> a = next->next()->vertex(); </li>
      <li> b = cur_halfedge->vertex(); </li>
      <li> c = twin->vertex(); </li>
      <li> d = twin->next()->next()->vertex(); </li>
    </ol>

    <p>Pointers to the two faces can be obtained as:</p>
    <ol>
      <li>The face containing cur_halfedge = cur_face = cur_halfedge->face()</li>
      <li>The face containing the twin half-edge = twin_face = twin->face()</li>
    </ol>

    <p>Once we have all the necessary pointers, we begin re-assigning them. We start with fixing the half-edges pointed to by the faces:</p>
    <ol>
      <li>cur_face->halfedge() = cur_halfedge</li>
      <li>twin->face()->halfedge() = twin</li>
    </ol>

    <p>Then, we fixed the half-edges as follows (pointers not mentioned here were left unchanged):</p>
    <ol>
      <li>cur_halfedge
        <ul>
          <li>->next() = dc</li>
          <li>->twin() = twin</li>
          <li>->vertex() = a</li>
          <li>->edge() = cur_edge</li>
          <li>->face() = cur_face</li>
        </ul>
      </li>
      <li>twin
        <ul>
          <li>->next() = ab</li>
          <li>->twin() = cur_halfedge</li>
          <li>->vertex() = d</li>
          <li>->edge() = cur_edge</li>
          <li>->face() = twin_face</li>
        </ul>
      </li>
      <li>ca
        <ul>
          <li>->next() = cur_halfedge</li>
          <li>->face() = cur_face</li>
        </ul>
      </li>
      <li>ab
        <ul>
          <li>->next() = bd</li>
          <li>->face() = twin_face</li>
        </ul>
      </li>
      <li>bd
        <ul>
          <li>->next() = twin</li>
          <li>->face() = twin_face</li>
        </ul>
      </li>
      <li>dc
        <ul>
          <li>->next() = ca</li>
          <li>->face() = cur_face</li>
        </ul>
      </li>
    </ol>

    <p>Finally, we fixed the half-edges pointed to by the vertices:</p>
    <ol>
      <li>a->halfedge() = cur_halfedge</li>
      <li>d->halfedge() = twin</li>
      <li>b->halfedge() = bd</li>
      <li>c->halfedge() = ca</li>
    </ol>

    Here are some screenshots showcasing the edge flip operation:
    <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="images/teapot_flip1.png" align="middle" width="400px" />
            <figcaption align="middle">Before flips</figcaption>
          </td>
          <td>
            <img src="images/teapot_flip2.png" align="middle" width="400px" />
            <figcaption align="middle">After flips</figcaption>
          </td>
        </tr>
        <br>
        <tr>
          <td>
            <img src="images/teapot_flip3.png" align="middle" width="400px" />
            <figcaption align="middle">Before flips</figcaption>
          </td>
          <td>
            <img src="images/teapot_flip4.png" align="middle" width="400px" />
            <figcaption align="middle">After flips</figcaption>
          </td>
        </tr>
      </table>
    </div>


    <h3 align="middle">Part 5: Half-edge split</h3>

    <p>Again, we mapped out the pointer assignments that need to be performed in order to split an edge on a piece of paper and then coded them up. We did not have to debug our code extensively because of this methodical approach. The only hiccup we had was due to our unfamiliarity with iterators. Specifically, we did not know how to create new objects using them. But the provided primer on iterators and their similarity to pointers was helpful in showing us how to allocate new objects. We use the notations from the figure below:</p>
    <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="images/split.png" align="middle" width="400px" />
            <figcaption align="middle">Split operation</figcaption>
          </td>
        </tr>
        <br>
      </table>
    </div>

    <p>Similar to the flip operation, we get pointers to the relevant half-edges by performing the following operations (cur_edge is the edge to be split):</p>
    <ol>
      <li> The half-edge pointed to by cur_edge = cur_halfedge = cur_edge->halfedge() </li>
      <li> The twin of half-edge pointed to by cur_edge = twin = cur_halfedge->twin() </li>
      <li> The next half-edge of the triangle containing the half-edge pointed to by cur_edge = next = cur_halfedge->next() </li>
      <li> The half-edge from c to a = ca = next </li>
      <li> The half-edge from d to c = dc = twin->next()->next() </li>
      <li> The half-edge from a to b = ab = next->next() </li>
      <li> The half-edge from b to d = bd = twin->next() </li>
    </ol>

    <p>The pointers to the existing vertices can be obtained as:</p>
    <ol>
      <li> a = next->next()->vertex(); </li>
      <li> b = cur_halfedge->vertex(); </li>
      <li> c = twin->vertex(); </li>
      <li> d = twin->next()->next()->vertex(); </li>
    </ol>

    <p>Pointers to the two existing faces can be obtained as:</p>
    <ol>
      <li>The face containing cur_halfedge = cur_face = cur_halfedge->face()</li>
      <li>The face containing the twin half-edge = twin_face = twin->face()</li>
    </ol>

    <p>Then, we create the new vertex m as follows (in our implementation cur_edge becomes the top half of the split edge and we create a new edge for the bottom half in later steps):</p>
    <ul>
      <li>m->position = (c->position + b->position) / 2.0</li>
      <li>m->halfedge() = cur_halfedge</li>
    </ul>

    <p>We also make sure that the existing vertices point to the edges that will be unchanged since some vertices might be pointing to the edge that is being split and thus may become problematic after the split:</p>
    <ol>
      <li> a->halfedge() = ab </li>
      <li> b->halfedge() = bd </li>
      <li> c->halfedge() = ca </li>
      <li> d->halfedge() = dc </li>
    </ol>

    <p>Next, we create the new faces - mab and dmb. We also fix the half-edges pointed to by the existing faces:</p>
    <ol>
      <li> mab->halfedge() = ab </li>
      <li> dmb->halfedge() = bd </li>
      <li> cur_face->halfedge() = ca </li>
      <li> twin_face->halfedge() = dc </li>
    </ol>

    <p>Finally, we create the new half-edges - bm, mb, am, ma, md and dm, and the new edges - AM, MD and BM. We perform the following pointer assignments to set up these new elements and also fix the existing half-edges and edges.</p>
    <ol>      
      In the cur_face:
      <li>ca->next() = am </li>
      <li>AM->halfedge() = am </li>
      <li>am->twin() = ma </li>
      <li>am->next() = cur_halfedge </li>
      <li>am->vertex() = a </li>
      <li>am->edge() = AM </li>
      <li>am->face() = cur_face </li>
      <li>cur_halfedge->vertex() = m </li>
      <br>

      In the new mab face:
      <li>ma->twin() = am </li>
      <li>ma->next() = ab </li>
      <li>ma->vertex() = m </li>
      <li>ma->edge() = AM </li>
      <li>ma->face() = mab </li>
      <li>ab->next() = bm </li>
      <li>ab->face() = mab </li>
      <li>BM->halfedge() = bm </li>
      <li>bm->twin() = mb </li>
      <li>bm->next() = ma </li>
      <li>bm->vertex() = b </li>
      <li>bm->edge() = BM </li>
      <li>bm->face() = mab </li>
      <br>

      In the twin face:
      <li>twin->next() = md </li>
      <li>MD->halfedge() = md </li>
      <li>md->twin() = dm </li>
      <li>md->next() = dc </li>
      <li>md->vertex() = m </li>
      <li>md->edge() = MD </li>
      <li>md->face() = twin_face </li>
      <br>

      In the new dmb face:
      <li>dm->twin() = md </li>
      <li>dm->next() = mb </li>
      <li>dm->vertex() = d </li>
      <li>dm->edge() = MD </li>
      <li>dm->face() = dmb </li>
      <li>mb->twin() = bm </li>
      <li>mb->next() = bd </li>
      <li>mb->vertex() = m </li>
      <li>mb->edge() = BM </li>
      <li>mb->face() = dmb </li>
      <li>bd->next() = dm </li>
      <li>bd->face() = dmb </li>
      <br>      
    </ol>

    Here are some screenshots showcasing the edge split operation:
    <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="images/teapot_split1.png" align="middle" width="400px" />
            <figcaption align="middle">Before splits</figcaption>
          </td>
          <td>
            <img src="images/teapot_split2.png" align="middle" width="400px" />
            <figcaption align="middle">After splits</figcaption>
          </td>
        </tr>
        <br>
        <tr>
          <td>
            <img src="images/teapot_split3.png" align="middle" width="400px" />
            <figcaption align="middle">Before splits</figcaption>
          </td>
          <td>
            <img src="images/teapot_split4.png" align="middle" width="400px" />
            <figcaption align="middle">After splits</figcaption>
          </td>
        </tr>
      </table>
    </div>

    Here are some screenshots showcasing the edge split and flip operations when combined:
    <div align="middle">
      <table style="width=100%">
        <tr>
          <td>
            <img src="images/teapot_split_flip1.png" align="middle" width="400px" />
            <figcaption align="middle">Before flips and splits</figcaption>
          </td>
          <td>
            <img src="images/teapot_split_flip2.png" align="middle" width="400px" />
            <figcaption align="middle">After flips and splits</figcaption>
          </td>
        </tr>
        <br>
        <tr>
          <td>
            <img src="images/teapot_split_flip3.png" align="middle" width="400px" />
            <figcaption align="middle">Before flips and splits</figcaption>
          </td>
          <td>
            <img src="images/teapot_split_flip4.png" align="middle" width="400px" />
            <figcaption align="middle">After flips and splits</figcaption>
          </td>
        </tr>
      </table>
    </div>



    <h3 align="middle">Part 6: Loop subdivision for mesh upsampling</h3>



    <h2 align="middle">Section III: Optional Extra Credit</h2>
    <p>If you are not participating in the optional mesh competition, don't worry about this section!</p>

    <h3 align="middle">Part 7: Design your own mesh!</h3>

</body>

</html>